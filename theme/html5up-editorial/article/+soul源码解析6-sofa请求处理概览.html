<!DOCTYPE HTML>
<!--
	Editorial by HTML5 UP
	html5up.net | @ajlkn
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>
 <head>
  <title>
   Editorial by HTML5 UP
  </title>
  <meta charset="utf-8"/>
  <meta content="width=device-width, initial-scale=1, user-scalable=no" name="viewport"/>
  <link href="../assets/css/main.css" rel="stylesheet"/>
 </head>
 <body class="is-preload">
  <!-- Wrapper -->
  <div id="wrapper">
   <!-- Main -->
   <div id="main">
    <div class="inner">
     <!-- Header -->
     <header id="header">
      <a class="logo" href="../index.html">
       <strong>
        每天进步一点点
       </strong>
      </a>
      <ul class="icons">
       <li>
        <a class="icon brands fa-twitter" href="#">
         <span class="label">
          Twitter
         </span>
        </a>
       </li>
       <li>
        <a class="icon brands fa-facebook-f" href="#">
         <span class="label">
          Facebook
         </span>
        </a>
       </li>
       <li>
        <a class="icon brands fa-snapchat-ghost" href="#">
         <span class="label">
          Snapchat
         </span>
        </a>
       </li>
       <li>
        <a class="icon brands fa-instagram" href="#">
         <span class="label">
          Instagram
         </span>
        </a>
       </li>
       <li>
        <a class="icon brands fa-medium-m" href="#">
         <span class="label">
          Medium
         </span>
        </a>
       </li>
      </ul>
     </header>
     <!-- Banner -->
     <section id="banner">
      <!-- <div class="content"> -->
      <article id="article">
       <h1>
        Soul 网关源码解析（五）Sofa请求处理概览
       </h1>
       <hr/>
       <h2>
        简介
       </h2>
       <p>
        今天来探索一下Sofa请求处理流程，看看和前面的HTTP、Dubbo有什么异同
       </p>
       <h2>
        Sofa示例运行
       </h2>
       <p>
        <em>
         PS：如果请求加上参数运行不成功，请更新最新版本，此问题在新版本中已经修复：https://blog.csdn.net/baidu_27627251/article/details/112726694
        </em>
        <em>
         <a href="https://github.com/dromara/soul/pull/992">
          Add sofa param resolve service
         </a>
        </em>
       </p>
       <p>
        首先运行下官方的Sofa示例，首先启动下mysql和zookeeper，这里使用docker启动：
       </p>
       <p>
        <pre>shell script
docker run -dit --name zk -p 2181:2181 zookeepe
docker run --name mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 -d mysql:latest</pre>
       </p>
       <p>
        然后运行Soul-admin，Soul-Bootst，在管理图界面起用sofa插件
       </p>
       <p>
        运行官方示例：soul-examples --&gt; soul-examples-sofa
       </p>
       <p>
        这里有个坑，需要注意，启动后，bootstrap打印日志中没有sofa插件，请求一直失败
       </p>
       <p>
        <pre>xml
o.d.s.w.configuration.SoulConfiguration  : load plugin:[global] [org.dromara.soul.plugin.global.GlobalPlugin]
o.d.s.w.configuration.SoulConfiguration  : load plugin:[sign] [org.dromara.soul.plugin.sign.SignPlugin]
o.d.s.w.configuration.SoulConfiguration  : load plugin:[waf] [org.dromara.soul.plugin.waf.WafPlugin]
o.d.s.w.configuration.SoulConfiguration  : load plugin:[rate_limiter] [org.dromara.soul.plugin.ratelimiter.RateLimiterPlugin]
o.d.s.w.configuration.SoulConfiguration  : load plugin:[hystrix] [org.dromara.soul.plugin.hystrix.HystrixPlugin]
o.d.s.w.configuration.SoulConfiguration  : load plugin:[resilience4j] [org.dromara.soul.plugin.resilience4j.Resilience4JPlugin]
o.d.s.w.configuration.SoulConfiguration  : load plugin:[divide] [org.dromara.soul.plugin.divide.DividePlugin]
o.d.s.w.configuration.SoulConfiguration  : load plugin:[webClient] [org.dromara.soul.plugin.httpclient.WebClientPlugin]
o.d.s.w.configuration.SoulConfiguration  : load plugin:[divide] [org.dromara.soul.plugin.divide.websocket.WebSocketPlugin]
o.d.s.w.configuration.SoulConfiguration  : load plugin:[alibaba-dubbo-body-param] [org.dromara.soul.plugin.alibaba.dubbo.param.BodyParamPlugin]
o.d.s.w.configuration.SoulConfiguration  : load plugin:[dubbo] [org.dromara.soul.plugin.alibaba.dubbo.AlibabaDubboPlugin]
o.d.s.w.configuration.SoulConfiguration  : load plugin:[monitor] [org.dromara.soul.plugin.monitor.MonitorPlugin]
o.d.s.w.configuration.SoulConfiguration  : load plugin:[response] [org.dromara.soul.plugin.httpclient.response.WebClientResponsePlugin]
o.d.s.w.configuration.SoulConfiguration  : load plugin:[response] [org.dromara.soul.plugin.alibaba.dubbo.response.DubboResponsePlugin]</pre>
        xml
       </p>
       <p>
        查看初始的plugins也是没有sofa
       </p>
       <p>
        <pre>java
    public SoulWebHandler soulWebHandler(final ObjectProvider&lt;List&lt;SoulPlugin&gt;&gt; plugins) {
        List&lt;SoulPlugin&gt; pluginList = plugins.getIfAvailable(Collections::emptyList);
        final List&lt;SoulPlugin&gt; soulPlugins = pluginList.stream()
                .sorted(Comparator.comparingInt(SoulPlugin::getOrder)).collect(Collectors.toList());
        soulPlugins.forEach(soulPlugin -&gt; log.info("load plugin:[{}] [{}]", soulPlugin.named(), soulPlugin.getClass().getName()));
        return new SoulWebHandler(soulPlugins);
    }</pre>
       </p>
       <p>
        经过探索和老哥的讨论，发现是没有起用sofa的相关依赖
       </p>
       <p>
        我们在Bootstrap的pom.xml文件中添加下面的依赖，然后重启
       </p>
       <p>
        <pre>xml
        &lt;!--        sofa plugin start--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.alipay.sofa&lt;/groupId&gt;
            &lt;artifactId&gt;sofa-rpc-all&lt;/artifactId&gt;
            &lt;version&gt;5.7.6&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;
            &lt;artifactId&gt;curator-client&lt;/artifactId&gt;
            &lt;version&gt;4.0.1&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;
            &lt;artifactId&gt;curator-framework&lt;/artifactId&gt;
            &lt;version&gt;4.0.1&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;
            &lt;artifactId&gt;curator-recipes&lt;/artifactId&gt;
            &lt;version&gt;4.0.1&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.dromara&lt;/groupId&gt;
            &lt;artifactId&gt;soul-spring-boot-starter-plugin-sofa&lt;/artifactId&gt;
            &lt;version&gt;${project.version}&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!--        sofa plugin end--&gt;</pre>
       </p>
       <p>
        然后查看日志打印，出现了sofa相关的插件
       </p>
       <p>
        <pre>xml
o.d.s.w.configuration.SoulConfiguration  : load plugin:[global] [org.dromara.soul.plugin.global.GlobalPlugin]
o.d.s.w.configuration.SoulConfiguration  : load plugin:[sign] [org.dromara.soul.plugin.sign.SignPlugin]
o.d.s.w.configuration.SoulConfiguration  : load plugin:[waf] [org.dromara.soul.plugin.waf.WafPlugin]
o.d.s.w.configuration.SoulConfiguration  : load plugin:[rate_limiter] [org.dromara.soul.plugin.ratelimiter.RateLimiterPlugin]
o.d.s.w.configuration.SoulConfiguration  : load plugin:[hystrix] [org.dromara.soul.plugin.hystrix.HystrixPlugin]
o.d.s.w.configuration.SoulConfiguration  : load plugin:[resilience4j] [org.dromara.soul.plugin.resilience4j.Resilience4JPlugin]
o.d.s.w.configuration.SoulConfiguration  : load plugin:[divide] [org.dromara.soul.plugin.divide.DividePlugin]
o.d.s.w.configuration.SoulConfiguration  : load plugin:[webClient] [org.dromara.soul.plugin.httpclient.WebClientPlugin]
o.d.s.w.configuration.SoulConfiguration  : load plugin:[divide] [org.dromara.soul.plugin.divide.websocket.WebSocketPlugin]
o.d.s.w.configuration.SoulConfiguration  : load plugin:[sofa-body-param] [org.dromara.soul.plugin.sofa.param.BodyParamPlugin]
o.d.s.w.configuration.SoulConfiguration  : load plugin:[dubbo] [org.dromara.soul.plugin.alibaba.dubbo.AlibabaDubboPlugin]
// 新出现的sofa相关的
o.d.s.w.configuration.SoulConfiguration  : load plugin:[sofa] [org.dromara.soul.plugin.sofa.SofaPlugin]
o.d.s.w.configuration.SoulConfiguration  : load plugin:[monitor] [org.dromara.soul.plugin.monitor.MonitorPlugin]
o.d.s.w.configuration.SoulConfiguration  : load plugin:[response] [org.dromara.soul.plugin.alibaba.dubbo.response.DubboResponsePlugin]
o.d.s.w.configuration.SoulConfiguration  : load plugin:[response] [org.dromara.soul.plugin.httpclient.response.WebClientResponsePlugin]
// 新出现的sofa相关的
o.d.s.w.configuration.SoulConfiguration  : load plugin:[response] [org.dromara.soul.plugin.sofa.response.SofaResponsePlugin]</pre>
       </p>
       <p>
        日志中还打印了成功加载sofa相关的metadata
       </p>
       <p>
        <pre>xml
o.d.s.p.s.cache.ApplicationConfigCache   : init sofa reference success there meteData is :MetaData
o.d.s.p.s.cache.ApplicationConfigCache   : init sofa reference success there meteData is :MetaData
o.d.s.p.s.cache.ApplicationConfigCache   : init sofa reference success there meteData is :MetaData</pre>
       </p>
       <p>
        访问链接： http://localhost:9195/sofa/findAll ，成功返回如下请求
       </p>
       <p>
        <pre>json
{
    "pre": 200,
    "message": "Access to success!",
    "data": {
        "name": "hello world Soul Sofa , findAll",
        "id": "998932133"
    }
}</pre>
       </p>
       <h2>
        源码解析
       </h2>
       <p>
        <em>
         PS:Debug时间过程，会导致超时，这是正常的
        </em>
       </p>
       <p>
        首先找到我们非常熟悉的切入点函数： SoulWebHandler ，在下面的方法中打上断点，然后逐步进入每个plugin观察其行为
       </p>
       <p>
        <pre>java
        public Mono&lt;Void&gt; execute(final ServerWebExchange exchange) {
            return Mono.defer(() -&gt; {
                if (this.index &lt; plugins.size()) {
                    SoulPlugin plugin = plugins.get(this.index++);
                    Boolean skip = plugin.skip(exchange);
                    if (skip) {
                        return this.execute(exchange);
                    }
                    return plugin.execute(exchange, this);
                }
                return Mono.empty();
            });
        }</pre>
       </p>
       <h3>
        GlobalPlugin
       </h3>
       <p>
        进入其中，执行处理逻辑，通过上篇的分析，我们知道大致作用是将请求类型放入exchange中
       </p>
       <h3>
        SignPlugin/WafPlugin/RateLimiterPlugin/HystrixPlugin/Resilience4JPlugin
       </h3>
       <p>
        进入其中，但plugin没有起用，不执行逻辑
       </p>
       <h3>
        DividePlugin/WebClientPlugin/WebSocketPlugin
       </h3>
       <p>
        通过类型判断，跳过，不执行
       </p>
       <h3>
        BodyParamPlugin
       </h3>
       <p>
        这个plugin在dubbo的时候也是要执行，我们来看看它干了写啥事。从下面逻辑中大概能看出先判断是否符合执行条件，然后将请求地址替换成真实的后端地址
       </p>
       <p>
        ```java
    public Mono
        <void>
         execute(final ServerWebExchange exchange, final SoulPluginChain chain) {
        final ServerHttpRequest request = exchange.getRequest();
        final SoulContext soulContext = exchange.getAttribute(Constants.CONTEXT);
        // 判断类型是不是sofa
        if (Objects.nonNull(soulContext) &amp;&amp; RpcTypeEnum.SOFA.getName().equals(soulContext.getRpcType())) {
            MediaType mediaType = request.getHeaders().getContentType();
            ServerRequest serverRequest = ServerRequest.create(exchange, messageReaders);
            if (MediaType.APPLICATION_JSON.isCompatibleWith(mediaType)) {
                return body(exchange, serverRequest, chain);
            }
            if (MediaType.APPLICATION_FORM_URLENCODED.isCompatibleWith(mediaType)) {
                return formData(exchange, serverRequest, chain);
            }
            // 进行路径替换，换成后端服务器的
            return query(exchange, serverRequest, chain);
        }
        return chain.execute(exchange);
    }
        </void>
       </p>
       <pre><pre>private Mono&lt;Void&gt; query(final ServerWebExchange exchange, final ServerRequest serverRequest, final SoulPluginChain chain) {
    exchange.getAttributes().put(Constants.SOFA_PARAMS,
            HttpParamConverter.ofString(() -&gt; serverRequest.uri().getQuery()));
    return chain.execute(exchange);
}
</pre></pre>
       <p>
        ```
       </p>
       <p>
        这里有个非常有趣的现象，我们第四篇分析中，dubbo也走了一模一样的类，在上面函数逻辑中，我们看出它并不能兼容dubbo，那dubbo是如何走这个类的呢？
       </p>
       <p>
        通过调试我们发现，当同时启动dubbo和sofa的时候，会生成两个BodyParamPlugin,名称是一模一样的，但里面的判断类型换了，很神奇，猜测这个类是动态生成之类的手段，这里先不探索了，可以后面研究研究
       </p>
       <h3>
        AlibabaDubboPlugin
       </h3>
       <p>
        通过类型判断，跳过
       </p>
       <h3>
        SofaPlugin
       </h3>
       <p>
        这个从名字就看出来是核心类，我们看看它具体干了啥。通过下面注释的地方，可以看出和dubbo请求的非常的相像。进行路由匹配，成功后rpc调用，获得结果后放入exchange中
       </p>
       <p>
        ```java
    # AbstractSoulPlugin
    public Mono
        <void>
         execute(final ServerWebExchange exchange, final SoulPluginChain chain) {
        String pluginName = named();
        final PluginData pluginData = BaseDataCache.getInstance().obtainPluginData(pluginName);
        if (pluginData != null &amp;&amp; pluginData.getEnabled()) {
            final Collection
         <selectordata>
          selectors = BaseDataCache.getInstance().obtainSelectorData(pluginName);
            if (CollectionUtils.isEmpty(selectors)) {
                return handleSelectorIsNull(pluginName, exchange, chain);
            }
            final SelectorData selectorData = matchSelector(exchange, selectors);
            if (Objects.isNull(selectorData)) {
                return handleSelectorIsNull(pluginName, exchange, chain);
            }
            selectorLog(selectorData, pluginName);
            final List
          <ruledata>
           rules = BaseDataCache.getInstance().obtainRuleData(selectorData.getId());
            if (CollectionUtils.isEmpty(rules)) {
                return handleRuleIsNull(pluginName, exchange, chain);
            }
            // 判断是否有路由规则能匹配上
            RuleData rule;
            if (selectorData.getType() == SelectorTypeEnum.FULL_FLOW.getCode()) {
                //get last
                rule = rules.get(rules.size() - 1);
            } else {
                rule = matchRule(exchange, rules);
            }
            if (Objects.isNull(rule)) {
                return handleRuleIsNull(pluginName, exchange, chain);
            }
            ruleLog(rule, pluginName);
            // 匹配上后执行处理逻辑
            return doExecute(exchange, chain, selectorData, rule);
        }
        return chain.execute(exchange);
    }
          </ruledata>
         </selectordata>
        </void>
       </p>
       <pre><pre># SofaPlugin
protected Mono&lt;Void&gt; doExecute(final ServerWebExchange exchange, final SoulPluginChain chain, final SelectorData selector, final RuleData rule) {
    String body = exchange.getAttribute(Constants.SOFA_PARAMS);
    SoulContext soulContext = exchange.getAttribute(Constants.CONTEXT);
    assert soulContext != null;
    MetaData metaData = exchange.getAttribute(Constants.META_DATA);
    if (!checkMetaData(metaData)) {
        assert metaData != null;
        log.error(" path is :{}, meta data have error.... {}", soulContext.getPath(), metaData.toString());
        exchange.getResponse().setStatusCode(HttpStatus.INTERNAL_SERVER_ERROR);
        Object error = SoulResultWrap.error(SoulResultEnum.META_DATA_ERROR.getCode(), SoulResultEnum.META_DATA_ERROR.getMsg(), null);
        return WebFluxResultUtils.result(exchange, error);
    }
    if (StringUtils.isNoneBlank(metaData.getParameterTypes()) &amp;&amp; StringUtils.isBlank(body)) {
        exchange.getResponse().setStatusCode(HttpStatus.INTERNAL_SERVER_ERROR);
        Object error = SoulResultWrap.error(SoulResultEnum.SOFA_HAVE_BODY_PARAM.getCode(), SoulResultEnum.SOFA_HAVE_BODY_PARAM.getMsg(), null);
        return WebFluxResultUtils.result(exchange, error);
    }
    // 这里得到结果，跟下去
    final Mono&lt;Object&gt; result = sofaProxyService.genericInvoker(body, metaData, exchange);
    return result.then(chain.execute(exchange));
}

# SofaProxyService
public Mono&lt;Object&gt; genericInvoker(final String body, final MetaData metaData, final ServerWebExchange exchange) throws SoulException {
    // 根据请求路径，获得rpc中的consumer 
    ConsumerConfig&lt;GenericService&gt; reference = ApplicationConfigCache.getInstance().get(metaData.getPath());
    if (Objects.isNull(reference) || StringUtils.isEmpty(reference.getInterfaceId())) {
        ApplicationConfigCache.getInstance().invalidate(metaData.getServiceName());
        reference = ApplicationConfigCache.getInstance().initRef(metaData);
    }
    GenericService genericService = reference.refer();
    Pair&lt;String[], Object[]&gt; pair;
    if (null == body || "".equals(body) || "{}".equals(body) || "null".equals(body)) {
        pair = new ImmutablePair&lt;&gt;(new String[]{}, new Object[]{});
    } else {
        pair = sofaParamResolveService.buildParameter(body, metaData.getParameterTypes());
    }
    CompletableFuture&lt;Object&gt; future = new CompletableFuture&lt;&gt;();
    RpcInvokeContext.getContext().setResponseCallback(new SofaResponseCallback&lt;Object&gt;() {
        @Override
        public void onAppResponse(final Object o, final String s, final RequestBase requestBase) {
            future.complete(o);
        }

        @Override
        public void onAppException(final Throwable throwable, final String s, final RequestBase requestBase) {
            future.completeExceptionally(throwable);
        }

        @Override
        public void onSofaException(final SofaRpcException e, final String s, final RequestBase requestBase) {
            future.completeExceptionally(e);
        }
    });
    // 通过函数名，能猜到是rpc调用，然后得到结果，并将结果放入exchange中
    genericService.$invoke(metaData.getMethodName(), pair.getLeft(), pair.getRight());
    return Mono.fromFuture(future.thenApply(ret -&gt; {
        if (Objects.isNull(ret)) {
            ret = Constants.SOFA_RPC_RESULT_EMPTY;
        }
        exchange.getAttributes().put(Constants.SOFA_RPC_RESULT, ret);
        exchange.getAttributes().put(Constants.CLIENT_RESPONSE_RESULT_TYPE, ResultEnum.SUCCESS.getName());
        return ret;
    })).onErrorMap(SoulException::new);
}
</pre></pre>
       <p>
        ```
       </p>
       <h3>
        MonitorPlugin
       </h3>
       <p>
        不跳过，但插件没有开启
       </p>
       <h3>
        DubboResponsePlugin/WebClientResponsePlugin
       </h3>
       <p>
        通过类型判断，跳过执行
       </p>
       <h3>
        SofaResponsePlugin
       </h3>
       <p>
        通过上几篇分析和名字能猜出来是将响应返回给客户端的，通过下面代码的逻辑也可以看出
       </p>
       <p>
        <pre>java
    public Mono&lt;Void&gt; execute(final ServerWebExchange exchange, final SoulPluginChain chain) {
        return chain.execute(exchange).then(Mono.defer(() -&gt; {
            // 从exchange中获取结果
            final Object result = exchange.getAttribute(Constants.SOFA_RPC_RESULT);
            if (Objects.isNull(result)) {
                Object error = SoulResultWrap.error(SoulResultEnum.SERVICE_RESULT_ERROR.getCode(), SoulResultEnum.SERVICE_RESULT_ERROR.getMsg(), null);
                return WebFluxResultUtils.result(exchange, error);
            }
            Object success = SoulResultWrap.success(SoulResultEnum.SUCCESS.getCode(), SoulResultEnum.SUCCESS.getMsg(), JsonUtils.removeClass(result));
            // 熟悉的返回响应的函数
            return WebFluxResultUtils.result(exchange, success);
        }));
    }</pre>
       </p>
       <h2>
        总结
       </h2>
       <p>
        上面的plugin流程大致如下：
       </p>
       <ul>
        <li>
         GlobalPlugin : 将请求类型置入
        </li>
        <li>
         SignPlugin : 跳过不执行逻辑
        </li>
        <li>
         WafPlugin : 跳过不执行逻辑
        </li>
        <li>
         RateLimiterPlugin : 跳过不执行逻辑
        </li>
        <li>
         HystrixPlugin : 跳过不执行逻辑
        </li>
        <li>
         Resilience4JPlugin : 跳过不执行逻辑
        </li>
        <li>
         DividePlugin : 跳过不执行逻辑
        </li>
        <li>
         WebClientPlugin : 跳过不执行逻辑
        </li>
        <li>
         WebSocketPlugin : 跳过不执行逻辑
        </li>
        <li>
         BodyParamPlugin : 执行RPC的请求路径替换，替换成真实的服务器后端路径，作用类似于dividePlugin；不同rpc有相关的这个插件名，也就是会有多个BodyParamPlugin
        </li>
        <li>
         AlibabaDubboPlugin : 跳过不执行逻辑
        </li>
        <li>
         SofaPlugin : 发送请求到后台服务器，拿到结果，写入exchange
        </li>
        <li>
         MonitorPlugin : 跳过不执行逻辑
        </li>
        <li>
         DubboResponsePlugin : 跳过不执行逻辑
        </li>
        <li>
         WebClientResponsePlugin : 跳过不执行逻辑
        </li>
        <li>
         SofaResponsePlugin : 从exchange中拿到响应，发送给客户端
        </li>
       </ul>
       <p>
        经过这几篇的分析，我们进一步优化我们对Soul网关的请求流程，大致如下：
       </p>
       <p>
        <img alt="" src="./picture/Soulprocessfirst.png"/>
       </p>
       <p>
        更新了我们对处理流程中一些类的认知：
       </p>
       <ul>
        <li>
         通过上篇分析，得到GlobalPlugin的具体作用，是置入请求类型
        </li>
        <li>
         BodyParamPlugin 作用类似于 dividePlugin，能进行路由匹配，匹配后将路径修改真实的后端服务器路径；并且能动态的生成同名的但针对不同rpc实现的plugin
        </li>
       </ul>
       <h2>
        Soul网关源码分析文章列表
       </h2>
       <h3>
        Github
       </h3>
       <ul>
        <li>
         <a href="https://github.com/lw1243925457/SE-Notes/blob/master/profession/program/%E5%BC%80%E6%BA%90/soul/soul%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB1-%E6%A6%82%E8%A7%88.md">
          Soul 源码阅读（一） 概览
         </a>
        </li>
        <li>
         <a href="https://github.com/lw1243925457/SE-Notes/blob/master/profession/program/%E5%BC%80%E6%BA%90/soul/soul%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB2-%E5%88%9D%E6%AD%A5%E8%BF%90%E8%A1%8C.md">
          Soul 源码阅读（二）代码初步运行
         </a>
        </li>
        <li>
         <a href="https://github.com/lw1243925457/SE-Notes/blob/master/profession/program/%E5%BC%80%E6%BA%90/soul/soul%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB3-%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E6%A6%82%E8%A7%88.md">
          Soul 源码阅读（三）HTTP请求处理概览
         </a>
        </li>
        <li>
         <a href="https://github.com/lw1243925457/SE-Notes/blob/master/profession/program/%E5%BC%80%E6%BA%90/soul/soul%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB4-dubbo%E8%AF%B7%E6%B1%82%E6%A6%82%E8%A7%88.md">
          Soul 网关源码阅读（四）Dubbo请求概览
         </a>
        </li>
        <li>
         <a href="https://github.com/lw1243925457/SE-Notes/blob/master/profession/program/%E5%BC%80%E6%BA%90/soul/soul%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB5-%E8%AF%B7%E6%B1%82%E7%B1%BB%E5%9E%8B%E6%8E%A2%E7%B4%A2.md">
          Soul网关源码阅读（五）请求类型探索
         </a>
        </li>
        <li>
         <a href="https://github.com/lw1243925457/SE-Notes/blob/master/profession/program/%E5%BC%80%E6%BA%90/soul/soul%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB6-sofa%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E6%A6%82%E8%A7%88.md">
          Soul 网关源码阅读（六）Sofa请求处理概览
         </a>
        </li>
       </ul>
       <h3>
        掘金
       </h3>
       <ul>
        <li>
         Soul 网关源码阅读（一） 概览 #掘金文章# https://juejin.cn/post/6917864624423436296
        </li>
        <li>
         Soul 网关源码阅读（二）代码初步运行 #掘金文章# https://juejin.cn/post/6917865804121767944
        </li>
        <li>
         Soul 网关源码阅读（三）请求处理概览 #掘金文章# https://juejin.cn/post/6917866538712334343
        </li>
        <li>
         Soul 网关源码阅读（四）Dubbo请求概览 #掘金文章# https://juejin.cn/post/6917867369909977102
        </li>
        <li>
         Soul网关源码阅读（五）请求类型探索 #掘金文章# https://juejin.cn/post/6918575905962983438
        </li>
       </ul>
      </article>
      <!-- </div> -->
     </section>
    </div>
   </div>
   <!-- Sidebar -->
   <div id="sidebar">
    <div class="inner">
     <!-- Menu -->
     <nav id="menu">
      <header class="major">
       <h2>
        目录
       </h2>
      </header>
      <ul>
       <li>
        <span class="opener">
         系统与软件
        </span>
        <ul>
         <li>
          <span class="opener">
           linux
          </span>
          <ul>
           <li>
            <a href="index.html">
             zsh.md
            </a>
           </li>
          </ul>
         </li>
         <li>
          <span class="opener">
           software
          </span>
          <ul>
           <li>
            <span class="opener">
             vscode
            </span>
            <ul>
             <li>
              <a href="index.html">
               vscode使用配置记录.md
              </a>
             </li>
            </ul>
           </li>
          </ul>
         </li>
         <li>
          <span class="opener">
           windows
          </span>
          <ul>
           <li>
            <a href="index.html">
             winSh中使用vim.md
            </a>
           </li>
          </ul>
         </li>
        </ul>
       </li>
       <li>
        <span class="opener">
         编程类
        </span>
        <ul>
         <li>
          <span class="opener">
           C++
          </span>
          <ul>
           <li>
            <a href="index.html">
             windows环境配置.md
            </a>
           </li>
          </ul>
         </li>
         <li>
          <span class="opener">
           git
          </span>
          <ul>
           <li>
            <a href="index.html">
             gitlab-CI.md
            </a>
           </li>
          </ul>
         </li>
         <li>
          <span class="opener">
           GoLang
          </span>
          <ul>
           <li>
            <a href="index.html">
             Go设置使用记录.md
            </a>
           </li>
          </ul>
         </li>
         <li>
          <span class="opener">
           java
          </span>
          <ul>
           <li>
            <span class="opener">
             spring
            </span>
            <ul>
             <li>
              <a href="index.html">
               SpringBoot-Mybatis-MySQL主从分离读写.md
              </a>
             </li>
            </ul>
           </li>
          </ul>
         </li>
         <li>
          <span class="opener">
           openCV
          </span>
          <ul>
           <li>
            <a href="index.html">
             轮廓检测.md
            </a>
           </li>
          </ul>
         </li>
         <li>
          <span class="opener">
           python
          </span>
          <ul>
           <li>
            <a href="index.html">
             Python3常用记录.md
            </a>
           </li>
          </ul>
         </li>
         <li>
          <span class="opener">
           SFML
          </span>
          <ul>
           <li>
            <a href="index.html">
             SFML与VS2015配置.md
            </a>
           </li>
          </ul>
         </li>
         <li>
          <span class="opener">
           人工智能
          </span>
          <ul>
           <li>
            <span class="opener">
             机器学习
            </span>
            <ul>
             <li>
              <a href="index.html">
               朴素贝叶斯分类器.md
              </a>
             </li>
            </ul>
           </li>
          </ul>
         </li>
         <li>
          <span class="opener">
           前端
          </span>
          <ul>
           <li>
            <a href="index.html">
             vue打包直接访问.md
            </a>
           </li>
          </ul>
         </li>
         <li>
          <span class="opener">
           开源
          </span>
          <ul>
           <li>
            <span class="opener">
             soul
            </span>
            <ul>
             <li>
              <a href="index.html">
               soul源码解析9-插件配置加载初探.md
              </a>
             </li>
            </ul>
           </li>
          </ul>
         </li>
        </ul>
       </li>
       <li>
        <span class="opener">
         通用类
        </span>
        <ul>
         <li>
          <a href="index.html">
           搜索技巧总结.md
          </a>
         </li>
        </ul>
       </li>
      </ul>
     </nav>
    </div>
   </div>
  </div>
  <!-- Scripts -->
  <script src="../assets/js/jquery.min.js">
  </script>
  <script src="../assets/js/browser.min.js">
  </script>
  <script src="../assets/js/breakpoints.min.js">
  </script>
  <script src="../assets/js/util.js">
  </script>
  <script src="../assets/js/main.js">
  </script>
 </body>
</html>