<!DOCTYPE HTML>
<!--
	Editorial by HTML5 UP
	html5up.net | @ajlkn
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>
 <head>
  <title>
   Editorial by HTML5 UP
  </title>
  <meta charset="utf-8"/>
  <meta content="width=device-width, initial-scale=1, user-scalable=no" name="viewport"/>
  <link href="../assets/css/main.css" rel="stylesheet"/>
 </head>
 <body class="is-preload">
  <!-- Wrapper -->
  <div id="wrapper">
   <!-- Main -->
   <div id="main">
    <div class="inner">
     <!-- Header -->
     <header id="header">
      <a class="logo" href="../index.html">
       <strong>
        每天进步一点点
       </strong>
      </a>
      <ul class="icons">
       <li>
        <a class="icon brands fa-twitter" href="#">
         <span class="label">
          Twitter
         </span>
        </a>
       </li>
       <li>
        <a class="icon brands fa-facebook-f" href="#">
         <span class="label">
          Facebook
         </span>
        </a>
       </li>
       <li>
        <a class="icon brands fa-snapchat-ghost" href="#">
         <span class="label">
          Snapchat
         </span>
        </a>
       </li>
       <li>
        <a class="icon brands fa-instagram" href="#">
         <span class="label">
          Instagram
         </span>
        </a>
       </li>
       <li>
        <a class="icon brands fa-medium-m" href="#">
         <span class="label">
          Medium
         </span>
        </a>
       </li>
      </ul>
     </header>
     <!-- Banner -->
     <section id="banner">
      <!-- <div class="content"> -->
      <article id="article">
       <h1>
        Soul网关源码解析（七）限流插件初探
       </h1>
       <hr/>
       <h2>
        简介
       </h2>
       <p>
        前面的文章中对处理流程探索的差不多了，今天来探索下限流插件:resilience4j
       </p>
       <h2>
        示例运行
       </h2>
       <h3>
        环境配置
       </h3>
       <p>
        启动下MySQL和redis
       </p>
       <p>
        <pre>shell script
docker run -dit --name redis -p 6379:6379 redis
docker run --name mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 -d mysql:latest</pre>
       </p>
       <h3>
        Soul-Admin启动及相关配置
       </h3>
       <p>
        运行Soul-admin，进入管理界面：系统管理 --&gt; 插件管理 --&gt; resilience4j ，点击编辑，把它开启
       </p>
       <p>
        进入管理界面的插件列表：resilience4j 添加选择器和规则，这里安装divide插件的匹配方式配的，让divide的/http前缀的接口都走限流（因为使用测试时官方本身自带的HTTP测试）
       </p>
       <p>
        规则配置中：token filling number 要设置大于0，不然会报错
       </p>
       <p>
        circuit enable 要设置为0，判断的时候走限流的逻辑
       </p>
       <p>
        其他的：fallback uri 随便填个路径，其他的参数都可填1
       </p>
       <h3>
        Soul-Bootstrap配置启动
       </h3>
       <p>
        在Soul-Bootstrap中进入相关的依赖，大致如下：
       </p>
       <p>
        ```xml
       </p>
       <!-- soul resilience4j plugin start-->
       <p>
        <dependency>
         <groupid>
          org.dromara
         </groupid>
         <artifactid>
          soul-spring-boot-starter-plugin-resilience4j
         </artifactid>
         <version>
          ${last.version}
         </version>
        </dependency>
        <!-- soul resilience4j plugin end-->
       </p>
       <p>
        ```
       </p>
       <p>
        启动Soul-Bootstrap
       </p>
       <h3>
        HTTP示例启动
       </h3>
       <p>
        启动：soul-examples --&gt; soul-examples-http --&gt; SoulTestHttpApplication
       </p>
       <p>
        进入管理界面的：插件列表 --&gt; divide 能看到相关的注册接口信息
       </p>
       <p>
        访问： http://127.0.0.1:9195/http/order/findById?id=1111
       </p>
       <p>
        成功运行，下面开始源码debug
       </p>
       <p>
        <pre>json
{
    "id": "1111",
    "name": "hello world findById"
}</pre>
       </p>
       <h2>
        源码Debug
       </h2>
       <h3>
        限流流程顺序跟踪确认
       </h3>
       <p>
        根据前面的文章，对处理流程基本上有个清晰的认识了，我们通过前面的调试，知道 RateLimiterPlugin 是继承 AbstractSoulPlugin ,那它就会走和路由匹配相关的逻辑，如下面对代码所示。匹配成功后才走 doExcute 限流逻辑
       </p>
       <p>
        ```java
    # AbstractSoulPlugin
    // 首先进行路由匹配
    public Mono
        <void>
         execute(final ServerWebExchange exchange, final SoulPluginChain chain) {
        String pluginName = named();
        final PluginData pluginData = BaseDataCache.getInstance().obtainPluginData(pluginName);
        if (pluginData != null &amp;&amp; pluginData.getEnabled()) {
            final Collection
         <selectordata>
          selectors = BaseDataCache.getInstance().obtainSelectorData(pluginName);
            if (CollectionUtils.isEmpty(selectors)) {
                return CheckUtils.checkSelector(pluginName, exchange, chain);
            }
            final SelectorData selectorData = matchSelector(exchange, selectors);
            if (Objects.isNull(selectorData)) {
                if (PluginEnum.WAF.getName().equals(pluginName)) {
                    return doExecute(exchange, chain, null, null);
                }
                return CheckUtils.checkSelector(pluginName, exchange, chain);
            }
            if (selectorData.getLoged()) {
                log.info("{} selector success match , selector name :{}", pluginName, selectorData.getName());
            }
            final List
          <ruledata>
           rules = BaseDataCache.getInstance().obtainRuleData(selectorData.getId());
            if (CollectionUtils.isEmpty(rules)) {
                if (PluginEnum.WAF.getName().equals(pluginName)) {
                    return doExecute(exchange, chain, null, null);
                }
                return CheckUtils.checkRule(pluginName, exchange, chain);
            }
            RuleData rule;
            if (selectorData.getType() == SelectorTypeEnum.FULL_FLOW.getCode()) {
                //get last
                rule = rules.get(rules.size() - 1);
            } else {
                rule = matchRule(exchange, rules);
            }
            if (Objects.isNull(rule)) {
                return CheckUtils.checkRule(pluginName, exchange, chain);
            }
            if (rule.getLoged()) {
                log.info("{} rule success match ,rule name :{}", pluginName, rule.getName());
            }
            return doExecute(exchange, chain, selectorData, rule);
        }
        return chain.execute(exchange);
    }
          </ruledata>
         </selectordata>
        </void>
       </p>
       <pre><pre># RateLimiterPlugin
// 匹配完成后走限流的逻辑
protected Mono&lt;Void&gt; doExecute(final ServerWebExchange exchange, final SoulPluginChain chain, final SelectorData selector, final RuleData rule) {
    final SoulContext soulContext = exchange.getAttribute(Constants.CONTEXT);
    assert soulContext != null;
    // 这里更加字符串转成对象，所有规则哪里不能乱填
    Resilience4JHandle resilience4JHandle = GsonUtils.getGson().fromJson(rule.getHandle(), Resilience4JHandle.class);
    // 这里判断 Circle enable 是否为1 走 combined的逻辑，但我们这次想走 limit 的逻辑，所以要填0
    if (resilience4JHandle.getCircuitEnable() == 1) {
        return combined(exchange, chain, rule);
    }
    return rateLimiter(exchange, chain, rule);
}

// 到这有些复杂，看的不是太懂，只能继续跟下去
private Mono&lt;Void&gt; rateLimiter(final ServerWebExchange exchange, final SoulPluginChain chain, final RuleData rule) {
    return ratelimiterExecutor.run(
            chain.execute(exchange), fallback(ratelimiterExecutor, exchange, null), Resilience4JBuilder.build(rule))
            .onErrorResume(throwable -&gt; ratelimiterExecutor.withoutFallback(exchange, throwable));
}
</pre></pre>
       <p>
        ```
       </p>
       <p>
        plugin前面代码还是看的懂，但rateLimiter开始就有些迷糊，流式编程的知识用上都看不懂了，但大致知道是进行限流逻辑
       </p>
       <p>
        ```java
public class RateLimiterExecutor implements Executor {
       </p>
       <pre><pre>@Override
public &lt;T&gt; Mono&lt;T&gt; run(final Mono&lt;T&gt; toRun, final Function&lt;Throwable, Mono&lt;T&gt;&gt; fallback, final Resilience4JConf conf) {
    // 生成限流器
    RateLimiter rateLimiter = Resilience4JRegistryFactory.rateLimiter(conf.getId(), conf.getRateLimiterConfig());
    // 应该是在这触发的限流逻辑
    Mono&lt;T&gt; to = toRun.transformDeferred(RateLimiterOperator.of(rateLimiter));
    if (fallback != null) {
        return to.onErrorResume(fallback);
    }
    return to;
}
</pre></pre>
       <p>
        }
```
       </p>
       <p>
        继续跟到上面那个类，我们看到了明显的生成限流器的逻辑，但有个让疑惑的是，因为返回的Mono，但没有看到明显的限流触发逻辑。在没有响应式编程的基础的时候感觉很懵，目前也没去定位真正的触发代码是在哪？但猜测是在上面注释中标注的那段触发的
       </p>
       <p>
        因为响应式，没有办法跟下去了，我们只能另找路径，看看具体的限流逻辑是什么样的
       </p>
       <p>
        通过上面知道：RateLimiter 是限流器，我们查看它的具体实现
       </p>
       <p>
        发现是一个接口，我们看看它有哪些实现，发现有两个： SemaphoreBasedRateLimiter 和 AtomicRateLimiter
       </p>
       <p>
        因为不知道用的哪个，我们在这两个类中可能会执行的函数都给打上断点
       </p>
       <p>
        重启发送请求，不断的跳断点，终于进入了一个限流器的类： AtomicRateLimiter ，大致如下
       </p>
       <p>
        <pre>java
    # AtomicRateLimiter
    public long reservePermission(final int permits) {
        long timeoutInNanos = ((AtomicRateLimiter.State)this.state.get()).config.getTimeoutDuration().toNanos();
        AtomicRateLimiter.State modifiedState = this.updateStateWithBackOff(permits, timeoutInNanos);
        boolean canAcquireImmediately = modifiedState.nanosToWait &lt;= 0L;
        if (canAcquireImmediately) {
            this.publishRateLimiterEvent(true, permits);
            return 0L;
        } else {
            boolean canAcquireInTime = timeoutInNanos &gt;= modifiedState.nanosToWait;
            if (canAcquireInTime) {
                this.publishRateLimiterEvent(true, permits);
                return modifiedState.nanosToWait;
            } else {
                this.publishRateLimiterEvent(false, permits);
                return -1L;
            }
        }
    }</pre>
       </p>
       <p>
        具体实现逻辑，不是我们此次关注的目的，此次是想看它在plugin中处理的流程顺序如何
       </p>
       <p>
        和前面几篇一样，我们在： SoulWebHandler 打上断点，看看限流器的执行顺序是什么样的
       </p>
       <p>
        通过debug，我们发现顺序和我们预期的基本一致：在进入 RateLimiterPlugin 插件执行的时候，执行的断点也到了限流器（AtomicRateLimiter),等限流器逻辑执行完毕，divide等插件才开始执行
       </p>
       <h3>
        关于执行处罚和Mono的一些思考
       </h3>
       <p>
        我们看一下下面限流执行的代码：
       </p>
       <p>
        ```java
public class RateLimiterExecutor implements Executor {
       </p>
       <pre><pre>@Override
public &lt;T&gt; Mono&lt;T&gt; run(final Mono&lt;T&gt; toRun, final Function&lt;Throwable, Mono&lt;T&gt;&gt; fallback, final Resilience4JConf conf) {
    // 生成限流器
    RateLimiter rateLimiter = Resilience4JRegistryFactory.rateLimiter(conf.getId(), conf.getRateLimiterConfig());
    // 应该是在这触发的限流逻辑
    Mono&lt;T&gt; to = toRun.transformDeferred(RateLimiterOperator.of(rateLimiter));
    if (fallback != null) {
        return to.onErrorResume(fallback);
    }
    return to;
}
</pre></pre>
       <p>
        }
```
       </p>
       <p>
        返回的一个Mono
       </p>
       <p>
        我们再看看divide之类的,也是返回的Mono
       </p>
       <p>
        ```java
public class DividePlugin extends AbstractSoulPlugin {
       </p>
       <pre><pre>@Override
protected Mono&lt;Void&gt; doExecute(final ServerWebExchange exchange, final SoulPluginChain chain, final SelectorData selector, final RuleData rule) {
    final SoulContext soulContext = exchange.getAttribute(Constants.CONTEXT);
    assert soulContext != null;
    final DivideRuleHandle ruleHandle = GsonUtils.getInstance().fromJson(rule.getHandle(), DivideRuleHandle.class);
    final List&lt;DivideUpstream&gt; upstreamList = UpstreamCacheManager.getInstance().findUpstreamListBySelectorId(selector.getId());
    if (CollectionUtils.isEmpty(upstreamList)) {
        log.error("divide upstream configuration error： {}", rule.toString());
        Object error = SoulResultWrap.error(SoulResultEnum.CANNOT_FIND_URL.getCode(), SoulResultEnum.CANNOT_FIND_URL.getMsg(), null);
        return WebFluxResultUtils.result(exchange, error);
    }
    final String ip = Objects.requireNonNull(exchange.getRequest().getRemoteAddress()).getAddress().getHostAddress();
    DivideUpstream divideUpstream = LoadBalanceUtils.selector(upstreamList, ruleHandle.getLoadBalance(), ip);
    if (Objects.isNull(divideUpstream)) {
        log.error("divide has no upstream");
        Object error = SoulResultWrap.error(SoulResultEnum.CANNOT_FIND_URL.getCode(), SoulResultEnum.CANNOT_FIND_URL.getMsg(), null);
        return WebFluxResultUtils.result(exchange, error);
    }
    // set the http url
    String domain = buildDomain(divideUpstream);
    String realURL = buildRealURL(domain, soulContext, exchange);
    exchange.getAttributes().put(Constants.HTTP_URL, realURL);
    // set the http timeout
    exchange.getAttributes().put(Constants.HTTP_TIME_OUT, ruleHandle.getTimeout());
    exchange.getAttributes().put(Constants.HTTP_RETRY, ruleHandle.getRetry());
    return chain.execute(exchange);
}
</pre></pre>
       <p>
        }
```
       </p>
       <p>
        再看看我们非常熟悉： SoulWebHandler
       </p>
       <p>
        <pre>java
        public Mono&lt;Void&gt; execute(final ServerWebExchange exchange) {
            return Mono.defer(() -&gt; {
                if (this.index &lt; plugins.size()) {
                    SoulPlugin plugin = plugins.get(this.index++);
                    Boolean skip = plugin.skip(exchange);
                    if (skip) {
                        return this.execute(exchange);
                    }
                    return plugin.execute(exchange, this);
                }
                return Mono.empty();
            });
        }</pre>
       </p>
       <p>
        在上面函数中，通过英文，可以看到所有的Plugin都是返回一个Mono
       </p>
       <p>
        我们结合响应式编程的相关概念：发布订阅。也就是说，这些plugin Mono 会发布到一个队列中，当订阅的时候，就会取出来顺序执行
       </p>
       <p>
        订阅的逻辑大致在那呢，我们翻一翻我们第三篇分析:
        <a href="https://juejin.cn/post/6917866538712334343">
         Soul 网关源码阅读（三）请求处理概览
        </a>
       </p>
       <p>
        在类：HttpServerHandle ，找到很可疑的一段，猜测应该是这：
       </p>
       <p>
        ```java
    public void onStateChange(Connection connection, State newState) {
        if (newState == HttpServerState.REQUEST_RECEIVED) {
            try {
                if (log.isDebugEnabled()) {
                    log.debug(ReactorNetty.format(connection.channel(), "Handler is being applied: {}"), new Object[]{this.handler});
                }
       </p>
       <pre><pre>            HttpServerOperations ops = (HttpServerOperations)connection;
            // 在这进行了发布和订阅，而handler.apply(ops, ops)会不断调用后面哪些plugin的逻辑
            Mono.fromDirect((Publisher)this.handler.apply(ops, ops)).subscribe(ops.disposeSubscriber());
        } catch (Throwable var4) {
            log.error(ReactorNetty.format(connection.channel(), ""), var4);
            connection.channel().close();
        }
    }

}
</pre></pre>
       <p>
        ```
       </p>
       <p>
        而限流的Mono是在divide之前，所以限流就先执行了，大致示意图如下：
       </p>
       <p>
        <img alt="" src="./picture/pluginProcess.png"/>
       </p>
       <p>
        大意是：fromDirect 函数触发将 Plugin Mono 放到队列中；subscribe函数，触发执行，执行顺序先进先出，则GlobalPlugin先进去的，则先开始执行（图中Global先进的，把上方看做队列底部，理解意思就行）。那顺序就对应上了我们的调试猜想
       </p>
       <p>
        还没深入研究响应式编程，所以也有可能是错的
       </p>
       <h3>
        疑问点
       </h3>
       <p>
        在下面这段生成限流器的逻辑中，好像每次请求过来都是进行一个新的生成，有没有可能进行复用，配置里面加一个字段，表示是否更新过，没有更新，我们就复用我们之前的限流器；有更新我们就新生成一个
       </p>
       <p>
        当然上面优化，需要在具体了解动态配置更新后，再看看是否可行
       </p>
       <p>
        也有可能是不熟悉Resilience4J,可能下面的代码中Resilience4JRegistryFactory本身实现了缓存复用
       </p>
       <p>
        ```java
public class RateLimiterExecutor implements Executor {
       </p>
       <pre><pre>@Override
public &lt;T&gt; Mono&lt;T&gt; run(final Mono&lt;T&gt; toRun, final Function&lt;Throwable, Mono&lt;T&gt;&gt; fallback, final Resilience4JConf conf) {
    // 生成限流器
    RateLimiter rateLimiter = Resilience4JRegistryFactory.rateLimiter(conf.getId(), conf.getRateLimiterConfig());
    // 应该是在这触发的限流逻辑
    Mono&lt;T&gt; to = toRun.transformDeferred(RateLimiterOperator.of(rateLimiter));
    if (fallback != null) {
        return to.onErrorResume(fallback);
    }
    return to;
}
</pre></pre>
       <p>
        }
```
       </p>
       <h2>
        总结
       </h2>
       <p>
        本次文章大致探索了限流插件：resilience4j的使用配置。调试验证它的限流逻辑执行在plugin链中执行顺序，发现基本符合我们的猜想，限流逻辑的执行和plugin顺序一致
       </p>
       <p>
        还初步讨论提出了plugin链在Mono队列中的执行猜想，后面研究响应式编程的时候验证一下猜想是否正常
       </p>
       <p>
        最后提出了一些对限流器生成的一些优化疑问，看后面配置更新相关的分析的时候，是否能验证自己的猜想
       </p>
       <h2>
        参考链接
       </h2>
       <ul>
        <li>
         <a href="https://dromara.org/zh-cn/docs/soul/plugin-resilience4j.html">
          resilience4j插件
         </a>
        </li>
        <li>
         <a href="https://blog.csdn.net/mickjoust/article/details/102411585">
          Resilience4j 源码解析（3）：限流模块 RateLimiter 与 常见限流算法
         </a>
        </li>
       </ul>
       <h2>
        Soul网关源码分析文章列表
       </h2>
       <h3>
        Github
       </h3>
       <ul>
        <li>
         <a href="https://github.com/lw1243925457/SE-Notes/blob/master/profession/program/%E5%BC%80%E6%BA%90/soul/soul%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB1-%E6%A6%82%E8%A7%88.md">
          Soul 源码阅读（一） 概览
         </a>
        </li>
        <li>
         <a href="https://github.com/lw1243925457/SE-Notes/blob/master/profession/program/%E5%BC%80%E6%BA%90/soul/soul%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB2-%E5%88%9D%E6%AD%A5%E8%BF%90%E8%A1%8C.md">
          Soul 源码阅读（二）代码初步运行
         </a>
        </li>
        <li>
         <a href="https://github.com/lw1243925457/SE-Notes/blob/master/profession/program/%E5%BC%80%E6%BA%90/soul/soul%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB3-%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E6%A6%82%E8%A7%88.md">
          Soul 源码阅读（三）HTTP请求处理概览
         </a>
        </li>
        <li>
         <a href="https://github.com/lw1243925457/SE-Notes/blob/master/profession/program/%E5%BC%80%E6%BA%90/soul/soul%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB4-dubbo%E8%AF%B7%E6%B1%82%E6%A6%82%E8%A7%88.md">
          Soul 网关源码阅读（四）Dubbo请求概览
         </a>
        </li>
        <li>
         <a href="https://github.com/lw1243925457/SE-Notes/blob/master/profession/program/%E5%BC%80%E6%BA%90/soul/soul%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB5-%E8%AF%B7%E6%B1%82%E7%B1%BB%E5%9E%8B%E6%8E%A2%E7%B4%A2.md">
          Soul网关源码阅读（五）请求类型探索
         </a>
        </li>
        <li>
         <p>
          <a href="https://github.com/lw1243925457/SE-Notes/blob/master/profession/program/%E5%BC%80%E6%BA%90/soul/soul%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB6-sofa%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E6%A6%82%E8%A7%88.md">
           Soul 网关源码阅读（六）Sofa请求处理概览
          </a>
         </p>
        </li>
        <li>
         <p>
          <a href="https://github.com/lw1243925457/SE-Notes/blob/master/profession/program/%E5%BC%80%E6%BA%90/soul/soul%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%95%AA%E5%A4%96%E7%AF%871-HTTP%E7%A4%BA%E4%BE%8B%E5%8F%82%E6%95%B0%E8%AF%B7%E6%B1%82%E9%94%99%E8%AF%AF.md">
           Soul网关源码阅读番外篇（一） HTTP参数请求错误
          </a>
         </p>
        </li>
       </ul>
       <h3>
        掘金
       </h3>
       <ul>
        <li>
         <a href="https://juejin.cn/post/6917864624423436296">
          Soul 网关源码阅读（一） 概览
         </a>
        </li>
        <li>
         <a href="https://juejin.cn/post/6917865804121767944">
          Soul 网关源码阅读（二）代码初步运行
         </a>
        </li>
        <li>
         <a href="https://juejin.cn/post/6917866538712334343">
          Soul 网关源码阅读（三）请求处理概览
         </a>
        </li>
        <li>
         <a href="https://juejin.cn/post/6917867369909977102">
          Soul 网关源码阅读（四）Dubbo请求概览
         </a>
        </li>
        <li>
         <a href="https://juejin.cn/post/6918575905962983438">
          Soul网关源码阅读（五）请求类型探索
         </a>
        </li>
        <li>
         <p>
          <a href="https://juejin.cn/post/6918736260467015693">
           Soul 网关源码阅读（六）Sofa请求处理概览
          </a>
         </p>
        </li>
        <li>
         <p>
          <a href="https://juejin.cn/post/6918947689564471309">
           Soul网关源码阅读番外篇（一） HTTP参数请求错误
          </a>
         </p>
        </li>
       </ul>
      </article>
      <!-- </div> -->
     </section>
    </div>
   </div>
   <!-- Sidebar -->
   <div id="sidebar">
    <div class="inner">
     <!-- Menu -->
     <nav id="menu">
      <header class="major">
       <h2>
        目录
       </h2>
      </header>
      <ul>
       <li>
        <span class="opener">
         linux
        </span>
        <ul>
         <li>
          <a href="index.html">
           centos.md
          </a>
         </li>
         <li>
          <a href="index.html">
           iptables端口转发与映射.md
          </a>
         </li>
         <li>
          <a href="index.html">
           Java安装.md
          </a>
         </li>
         <li>
          <a href="index.html">
           linux-时间校准.md
          </a>
         </li>
         <li>
          <a href="index.html">
           Linux服务编写及服务开机启动.md
          </a>
         </li>
         <li>
          <a href="index.html">
           shadowsocks.md
          </a>
         </li>
         <li>
          <a href="index.html">
           ssh隧道.md
          </a>
         </li>
         <li>
          <a href="index.html">
           supervisor使用.md
          </a>
         </li>
         <li>
          <a href="index.html">
           yapi.md
          </a>
         </li>
         <li>
          <a href="index.html">
           zsh.md
          </a>
         </li>
        </ul>
       </li>
       <li>
        <span class="opener">
         software
        </span>
        <ul>
         <li>
          <span class="opener">
           docker
          </span>
          <ul>
           <li>
            <a href="index.html">
             Java程序镜像制作.md
            </a>
           </li>
          </ul>
         </li>
         <li>
          <span class="opener">
           jetbranins
          </span>
          <ul>
           <li>
            <a href="index.html">
             Pycharm使用记录.md
            </a>
           </li>
          </ul>
         </li>
         <li>
          <span class="opener">
           kafka
          </span>
          <ul>
           <li>
            <a href="index.html">
             kafkaDocker集群搭建.md
            </a>
           </li>
          </ul>
         </li>
         <li>
          <span class="opener">
           MongoDB
          </span>
          <ul>
           <li>
            <a href="index.html">
             Python-MongoDB.md
            </a>
           </li>
          </ul>
         </li>
         <li>
          <span class="opener">
           MySQL
          </span>
          <ul>
           <li>
            <a href="index.html">
             MySQL使用记录.md
            </a>
           </li>
          </ul>
         </li>
         <li>
          <span class="opener">
           nagios
          </span>
          <ul>
           <li>
            <a href="index.html">
             nagios添加主机和服务监控说明.md
            </a>
           </li>
          </ul>
         </li>
         <li>
          <span class="opener">
           neo4j
          </span>
          <ul>
           <li>
            <a href="index.html">
             neo4j使用记录.md
            </a>
           </li>
          </ul>
         </li>
         <li>
          <span class="opener">
           nginx
          </span>
          <ul>
           <li>
            <a href="index.html">
             nginx负载均衡.md
            </a>
           </li>
          </ul>
         </li>
         <li>
          <span class="opener">
           Redis
          </span>
          <ul>
           <li>
            <a href="index.html">
             Redis知识总览.md
            </a>
           </li>
          </ul>
         </li>
         <li>
          <span class="opener">
           snort
          </span>
          <ul>
           <li>
            <a href="index.html">
             Snort调研.md
            </a>
           </li>
          </ul>
         </li>
         <li>
          <span class="opener">
           sublimeText
          </span>
          <ul>
           <li>
            <a href="index.html">
             ubuntu16.04_install.md
            </a>
           </li>
          </ul>
         </li>
         <li>
          <span class="opener">
           vim
          </span>
          <ul>
           <li>
            <a href="index.html">
             Ctenos7-vim8安装.md
            </a>
           </li>
          </ul>
         </li>
         <li>
          <span class="opener">
           virsual_studio
          </span>
          <ul>
           <li>
            <a href="index.html">
             插件安装篇.md
            </a>
           </li>
          </ul>
         </li>
         <li>
          <span class="opener">
           vscode
          </span>
          <ul>
           <li>
            <a href="index.html">
             vscode使用配置记录.md
            </a>
           </li>
          </ul>
         </li>
        </ul>
       </li>
       <li>
        <span class="opener">
         windows
        </span>
        <ul>
         <li>
          <a href="index.html">
           superbenchmarker.md
          </a>
         </li>
         <li>
          <a href="index.html">
           windows10.md
          </a>
         </li>
         <li>
          <a href="index.html">
           winSh中使用vim.md
          </a>
         </li>
        </ul>
       </li>
       <li>
        <span class="opener">
         C++
        </span>
        <ul>
         <li>
          <a href="index.html">
           windows环境配置.md
          </a>
         </li>
        </ul>
       </li>
       <li>
        <span class="opener">
         git
        </span>
        <ul>
         <li>
          <a href="index.html">
           gitlab-CI.md
          </a>
         </li>
        </ul>
       </li>
       <li>
        <span class="opener">
         GoLang
        </span>
        <ul>
         <li>
          <a href="index.html">
           Go设置使用记录.md
          </a>
         </li>
        </ul>
       </li>
       <li>
        <span class="opener">
         java
        </span>
        <ul>
         <li>
          <span class="opener">
           shardingsphere
          </span>
          <ul>
           <li>
            <a href="index.html">
             ShardingSphereProxy分库分表.md
            </a>
           </li>
          </ul>
         </li>
         <li>
          <span class="opener">
           spring
          </span>
          <ul>
           <li>
            <a href="index.html">
             SpringBoot-Mybatis-MySQL主从分离读写.md
            </a>
           </li>
          </ul>
         </li>
        </ul>
       </li>
       <li>
        <span class="opener">
         openCV
        </span>
        <ul>
         <li>
          <a href="index.html">
           轮廓检测.md
          </a>
         </li>
        </ul>
       </li>
       <li>
        <span class="opener">
         python
        </span>
        <ul>
         <li>
          <a href="index.html">
           Python3常用记录.md
          </a>
         </li>
        </ul>
       </li>
       <li>
        <span class="opener">
         SFML
        </span>
        <ul>
         <li>
          <a href="index.html">
           SFML与VS2015配置.md
          </a>
         </li>
        </ul>
       </li>
       <li>
        <span class="opener">
         人工智能
        </span>
        <ul>
         <li>
          <span class="opener">
           机器学习
          </span>
          <ul>
           <li>
            <a href="index.html">
             朴素贝叶斯分类器.md
            </a>
           </li>
          </ul>
         </li>
        </ul>
       </li>
       <li>
        <span class="opener">
         前端
        </span>
        <ul>
         <li>
          <a href="index.html">
           vue打包直接访问.md
          </a>
         </li>
        </ul>
       </li>
       <li>
        <span class="opener">
         开源
        </span>
        <ul>
         <li>
          <span class="opener">
           soul
          </span>
          <ul>
           <li>
            <a href="index.html">
             soul源码解析9-插件配置加载初探.md
            </a>
           </li>
          </ul>
         </li>
        </ul>
       </li>
      </ul>
     </nav>
    </div>
   </div>
  </div>
  <!-- Scripts -->
  <script src="../assets/js/jquery.min.js">
  </script>
  <script src="../assets/js/browser.min.js">
  </script>
  <script src="../assets/js/breakpoints.min.js">
  </script>
  <script src="../assets/js/util.js">
  </script>
  <script src="../assets/js/main.js">
  </script>
 </body>
</html>