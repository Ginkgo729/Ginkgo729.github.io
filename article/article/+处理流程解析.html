<!DOCTYPE HTML>
<!--
	Dimension by HTML5 UP
	html5up.net | @ajlkn
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>
 <head>
  <title>
   Dimension by HTML5 UP
  </title>
  <!-- <meta charset="utf-8" /> -->
  <!-- <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" /> -->
  <meta charset="utf-8"/>
  <meta content="width=device-width,initial-scale=1.0" name="viewport"/>
  <link href="../../assets/css/article.css" rel="stylesheet"/>
  <noscript>
   <link href="../../assets/css/noscript.css" rel="stylesheet"/>
  </noscript>
 </head>
 <body>
  <div id="app">
  </div>
  <!-- built files will be auto injected -->
 </body>
 <body class="is-article-visible">
  <!--	<body class="is-preload">-->
  <!-- Wrapper -->
  <div id="wrapper">
   <nav>
    <ul>
     <li>
      <a href="#intro">
       主页
      </a>
     </li>
     <li>
      <a href="#experience">
       文章列表
      </a>
     </li>
    </ul>
   </nav>
   <article class="active" id="article" style="display: block">
    <h1>
     Spring Cloud Gateway （七）处理流程解析
    </h1>
    <hr/>
    <h2>
     简介
    </h2>
    <p>
     初步梳理 Spring Cloud Gateway 的处理流程
    </p>
    <h3>
     过程记录
    </h3>
    <h4>
     主要请求流程
    </h4>
    <p>
     在前面的分析中，我们知道在 RoutePredicateHandlerMapping 中是实现了路由查找，于是在这个类中 getHandlerInternal 函数打上断点，通过调用栈向前追溯调用
    </p>
    <p>
     向前我们追溯到了 DispatcherHandler ,在这个断点处通过断点调试发现有类似循环的操作，这个感觉是查找相应 handler 进行处理，细节部分暂时不够，后面再来详细看
    </p>
    <p>
     <pre>java
    public Mono&lt;Void&gt; handle(ServerWebExchange exchange) {
        return this.handlerMappings == null ? this.createNotFoundError() : Flux.fromIterable(this.handlerMappings).concatMap((mapping) -&gt; {
            return mapping.getHandler(exchange);
        }).next().switchIfEmpty(this.createNotFoundError()).flatMap((handler) -&gt; {
            return this.invokeHandler(exchange, handler);
        }).flatMap((result) -&gt; {
            return this.handleResult(exchange, result);
        });
    }</pre>
    </p>
    <p>
     在上面函数打断点，再通过调用栈向前查找，找到 netty 相关的一个类： HttpServerHandle 。下面的函数中有类似 Mono 这里的代码，发布后触发调用
    </p>
    <p>
     ```java
    public void onStateChange(Connection connection, State newState) {
        if (newState == HttpServerState.REQUEST_RECEIVED) {
            try {
                if (log.isDebugEnabled()) {
                    log.debug(ReactorNetty.format(connection.channel(), "Handler is being applied: {}"), new Object[]{this.handler});
                }
    </p>
    <pre><pre>            HttpServerOperations ops = (HttpServerOperations)connection;
            // Mono 发布,这一步需要注意，跟踪handler下去
            Mono.fromDirect((Publisher)this.handler.apply(ops, ops)).subscribe(ops.disposeSubscriber());
        } catch (Throwable var4) {
            log.error(ReactorNetty.format(connection.channel(), ""), var4);
            connection.channel().close();
        }
    }
}
</pre></pre>
    <p>
     ```
    </p>
    <p>
     在上面注释的地方打上断点，进入相应类及其方法，跳入下面的 ReactorHttpHandlerAdapter , 其中再次调用了其他的 handler，进行参数的传递，我们再接着跟下去
    </p>
    <p>
     ```java
    public Mono
     <void>
      apply(HttpServerRequest reactorRequest, HttpServerResponse reactorResponse) {
        NettyDataBufferFactory bufferFactory = new NettyDataBufferFactory(reactorResponse.alloc());
     </void>
    </p>
    <pre><pre>    try {
        ReactorServerHttpRequest request = new ReactorServerHttpRequest(reactorRequest, bufferFactory);
        ServerHttpResponse response = new ReactorServerHttpResponse(reactorResponse, bufferFactory);
        if (request.getMethod() == HttpMethod.HEAD) {
            response = new HttpHeadResponseDecorator((ServerHttpResponse)response);
        }

        // 这一步再次调用其他的 handler 进行传递，再次跟踪下去
        return this.httpHandler.handle(request, (ServerHttpResponse)response).doOnError((ex) -&gt; {
            logger.trace(request.getLogPrefix() + "Failed to complete: " + ex.getMessage());
        }).doOnSuccess((aVoid) -&gt; {
            logger.trace(request.getLogPrefix() + "Handling completed");
        });
    } catch (URISyntaxException var6) {
        if (logger.isDebugEnabled()) {
            logger.debug("Failed to get request URI: " + var6.getMessage());
        }

        reactorResponse.status(HttpResponseStatus.BAD_REQUEST);
        return Mono.empty();
    }
}
</pre></pre>
    <p>
     ```
    </p>
    <p>
     接着跳到了：WebServerManager ，里面进行了一次调用，来到了 HttpWebHandlerAdapter ,
    </p>
    <p>
     ```java
    public Mono
     <void>
      handle(ServerHttpRequest request, ServerHttpResponse response) {
        if (this.forwardedHeaderTransformer != null) {
            request = this.forwardedHeaderTransformer.apply(request);
        }
     </void>
    </p>
    <pre><pre>    // 看到了熟悉，非常关键的exchange的生成，终于定位到了 exchange 的来源了
    ServerWebExchange exchange = this.createExchange(request, response);
    LogFormatUtils.traceDebug(logger, (traceOn) -&gt; {
        return exchange.getLogPrefix() + this.formatRequest(exchange.getRequest()) + (traceOn ? ", headers=" + this.formatHeaders(exchange.getRequest().getHeaders()) : "");
    });

    // delegate 和 filter 息息相关，继续跟下去
    Mono var10000 = this.getDelegate().handle(exchange).doOnSuccess((aVoid) -&gt; {
        this.logResponse(exchange);
    }).onErrorResume((ex) -&gt; {
        return this.handleUnresolvedError(exchange, ex);
    });
    response.getClass();
    return var10000.then(Mono.defer(response::setComplete));
}
</pre></pre>
    <p>
     ```
    </p>
    <p>
     接着到了： DispatcherHandler ，回到了最开始的切入点，看到其中大致是调用各个 mapping 进行处理
    </p>
    <p>
     <pre>java
    public Mono&lt;Void&gt; handle(ServerWebExchange exchange) {
        return this.handlerMappings == null ? this.createNotFoundError() : Flux.fromIterable(this.handlerMappings).concatMap((mapping) -&gt; {
            return mapping.getHandler(exchange);
        }).next().switchIfEmpty(this.createNotFoundError()).flatMap((handler) -&gt; {
            // handler 调用
            return this.invokeHandler(exchange, handler);
        }).flatMap((result) -&gt; {
            return this.handleResult(exchange, result);
        });
    }</pre>
    </p>
    <p>
     查看 handlerMappings ，它有6个，routePredicateHandlerMapping 是熟悉的重要的，它会逐个调用各个 Mapping 的 getHandler 方法，不同的 Mapping 实现了不同的 getHandlerInternal 方法，成功的话返回 FilteringWebHandler
    </p>
    <p>
     ```java
    public Mono
     <object>
      getHandler(ServerWebExchange exchange) {
        // 调用 getHandlerInternal ，不同的 Mapping 有各自的实现
        return this.getHandlerInternal(exchange).map((handler) -&gt; {
            if (this.logger.isDebugEnabled()) {
                this.logger.debug(exchange.getLogPrefix() + "Mapped to " + handler);
            }
     </object>
    </p>
    <pre><pre>        ServerHttpRequest request = exchange.getRequest();
        if (this.hasCorsConfigurationSource(handler) || CorsUtils.isPreFlightRequest(request)) {
            CorsConfiguration config = this.corsConfigurationSource != null ? this.corsConfigurationSource.getCorsConfiguration(exchange) : null;
            CorsConfiguration handlerConfig = this.getCorsConfiguration(handler, exchange);
            config = config != null ? config.combine(handlerConfig) : handlerConfig;
            if (!this.corsProcessor.process(config, exchange) || CorsUtils.isPreFlightRequest(request)) {
                return REQUEST_HANDLED_HANDLER;
            }
        }

        // 这里 debug 返回 FilteringWebHandler
        return handler;
    });
}

protected abstract Mono&lt;?&gt; getHandlerInternal(ServerWebExchange var1);
</pre></pre>
    <p>
     ```
    </p>
    <p>
     getHandlerInternal(exchange) 调用跳到 RoutePredicateHandlerMapping ，其中关键的是绑定上定制化的 filter
    </p>
    <p>
     ```java
    @Override
    protected Mono&lt;?&gt; getHandlerInternal(ServerWebExchange exchange) {
        // don't handle requests on management port if set and different than server port
        if (this.managementPortType == DIFFERENT &amp;&amp; this.managementPort != null
                &amp;&amp; exchange.getRequest().getURI().getPort() == this.managementPort) {
            return Mono.empty();
        }
        exchange.getAttributes().put(GATEWAY_HANDLER_MAPPER_ATTR, getSimpleName());
    </p>
    <pre><pre>    return lookupRoute(exchange)
            // .log("route-predicate-handler-mapping", Level.FINER) //name this
            .flatMap((Function&lt;Route, Mono&lt;?&gt;&gt;) r -&gt; {
                exchange.getAttributes().remove(GATEWAY_PREDICATE_ROUTE_ATTR);
                if (logger.isDebugEnabled()) {
                    logger.debug(
                            "Mapping [" + getExchangeDesc(exchange) + "] to " + r);
                }

                // r 是它独有的filter 处理器
                exchange.getAttributes().put(GATEWAY_ROUTE_ATTR, r);

                // webHandler 是全局链
                return Mono.just(webHandler);
            }).switchIfEmpty(Mono.empty().then(Mono.fromRunnable(() -&gt; {
                exchange.getAttributes().remove(GATEWAY_PREDICATE_ROUTE_ATTR);
                if (logger.isTraceEnabled()) {
                    logger.trace("No RouteDefinition found for ["
                            + getExchangeDesc(exchange) + "]");
                }
            })));
}
</pre></pre>
    <p>
     ```
    </p>
    <p>
     在上面的 Mapping 中处理完成后，返回 handler ，然后this.invokeHandler(exchange, handler), 跳转到 FilteringWebHandler ,在其中从 exchange 中取出定制化的 filter，和 global filter 排序融合在一起，最后结合前面的：
     <a href="https://github.com/lw1243925457/SE-Notes/blob/master/profession/program/java/spring/springcloudGateway/%E6%B5%81%E7%A8%8B%E7%B1%BB.md">
      Spring cloud Gateway（二） 一个Http请求的流程解析
     </a>
     ，整个流程就串起来了
    </p>
    <p>
     ```java
    public Mono
     <void>
      handle(ServerWebExchange exchange) {
        // 这里是获取特定转发的filter列表
        Route route = exchange.getRequiredAttribute(GATEWAY_ROUTE_ATTR);
        List
      <gatewayfilter>
       gatewayFilters = route.getFilters();
      </gatewayfilter>
     </void>
    </p>
    <pre><pre>    // 获取全局filter列表，和上面的排序组合成新的filter
    List&lt;GatewayFilter&gt; combined = new ArrayList&lt;&gt;(this.globalFilters);
    combined.addAll(gatewayFilters);
    // TODO: needed or cached?
    AnnotationAwareOrderComparator.sort(combined);

    if (logger.isDebugEnabled()) {
        logger.debug("Sorted gatewayFilterFactories: " + combined);
    }

    // 触发调用
    return new DefaultGatewayFilterChain(combined).filter(exchange);
}
</pre></pre>
    <p>
     ```
    </p>
    <h3>
     总结
    </h3>
    <p>
     结合前面的分析，那处理流程大致如下如下：
    </p>
    <ul>
     <li>
      HttpServerHandle : netty 的服务端，接收客户端请求
     </li>
     <li>
      ReactorHttpHandlerAdapter : 一个承接的作用
     </li>
     <li>
      HttpWebHandlerAdapter : 对 exchange 这个重要变量的组装,触发跳转 DispatcherHandler
     </li>
     <li>
      DispatcherHandler : 请求调度器，负责请求分发，首先调用到 route 匹配模块，对 exchange 传入定制化的 filter，成功后进行 filter 相关调用
     </li>
     <li>
      RoutePredicateHandlerMapping : 路由匹配操作，绑定定制化的 filter 到 exchange 上
     </li>
     <li>
      FilteringWebHandler : 使用 filter 链表处理请求
     </li>
     <li>
      Filter : 一系列的操作， WebsocketRoutingFilter/NettyRoutingFilter 负责请求到后台服务器并接受请求， NettyWriteResponseFilter 返回响应到客户端
     </li>
    </ul>
    <p>
     完整的处理流程图大致如下：
    </p>
    <p>
     <img alt="" src="./picture/fullyProcess.png"/>
    </p>
    <p>
     想到之前秦老师说的：Spring Cloud Gateway基于spring体系，所以偷了个懒，可以直接用spring mvc作为请求接入。到这里有些名称，在图中前面都是使用的react-netty服务相关的(HttpServerHandle和ReactorHttpHandlerAdapter)，Spring web(HttpWebHandlerAdapter)类似做一个承接,后面开始路由匹配和filter。其中最有特色的是，请求和响应和发送都是在filter里面做的，可以说filter做了很多核心的功能了
    </p>
    <p>
     后面的filter流程下面的文章链接中：
    </p>
    <ul>
     <li>
      <a href="https://github.com/lw1243925457/SE-Notes/blob/master/profession/program/java/spring/springcloudGateway/%E6%B5%81%E7%A8%8B%E7%B1%BB.md">
       Spring cloud Gateway（二） 一个Http请求的流程解析
      </a>
     </li>
    </ul>
   </article>
  </div>
  <!-- BG -->
  <div id="bg">
  </div>
  <!-- Scripts -->
  <script src="../../assets/js/jquery.min.js">
  </script>
  <script src="../../assets/js/browser.min.js">
  </script>
  <script src="../../assets/js/breakpoints.min.js">
  </script>
  <script src="../../assets/js/util.js">
  </script>
  <script src="../../assets/js/main.js">
  </script>
 </body>
</html>
